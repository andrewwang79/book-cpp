# QT通讯
## 消息机制
 > [信号与槽工作原理](https://woboq.com/blog/how-qt-signals-slots-work.html)

### 基于对象的线程模型
* 将每个对象绑定到一个特定的线程(对象创建时所在的线程)，每个线程有事件循环
* 对象会使用其绑定线程的事件循环处理，而不是当前运行中的线程。在接收方对象所属的线程执行槽函数，确保了线程安全、对象状态一致性和简化编程模型。
* QObject::moveToThread可以改变对象绑定的线程
* 通过智能指针传递大数据，否则自定义结构会深拷贝
* QObject::deleteLater是QObject 类的一个成员函数。当你调用这个函数时，它会将一个事件排入事件循环，请求在控制权返回事件循环时删除对象。这个特性在跨线程操作时特别有用，因为它能确保对象被安全地删除，而且是在适当的线程上。

> 两种机制：全局信号槽机制，事件过滤器

### emit
1. 跨窗口或者后台服务的消息通知用emit
1. Qt会在信号接收对象所在的线程中调用槽函数。如果信号和接收对象在同一线程中，则槽函数将直接在该线程中执行。如果信号和接收对象不在同一线程中，则Qt会将槽函数的执行请求发送到接收对象所在的线程，并在那里执行槽函数。

## 最佳实践
1. 在组件内部定义connect ： 如果信号和槽的连接逻辑紧密相关于组件的内部行为，可以在组件内部定义 connect。这种方式有助于组件的封装性和自包含性。
1. 在窗口定义connect：如果信号和槽的连接涉及多个组件的交互，通常在窗口中定义 connect。这样可以集中管理组件之间的交互逻辑，保持组件的独立性和重用性。
1. 在专门的管理对象定义connect：如中介者(Controller)或事件总线（Event Bus）。前者一般1对1一个窗口，后者是系统级的（signal有分类区分不同的窗口）